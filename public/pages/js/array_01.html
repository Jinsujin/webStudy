<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

<script>
    /**
     * 배열 array
     * 
     *  
     * 
    */


    const arr1 = new Array();
    const arr2 = [1,2];

    const fruits = ['🍎', '🍇'];
    console.log(fruits.length);
    console.log(fruits[0]); // 사과
    console.log(fruits[2]); //  undefined
    console.log(fruits[fruits.length - 1]);// 마지막 데이터 접근

    console.clear();
    console.log();

    for(let i = 0; i < fruits.length; i++){
        console.log(fruits[i]);
    }

    for(let fruits of fruits){
        console.log(fruits);
    }

    fruits.forEach((fruit) => console.log(fruit) );

    fruits.push('🍙', '🍩');
    console.log(fruits);

    fruits.pop();
    fruits.pop();
    console.log(fruits);

    // 앞에서 넣기 : unshift
    fruits.unshift('🥨');

    // 앞에서 데이터 빼기 : shift
    fruits.shift();
    console.log(fruits);

    /**
     * shift, unshift 단점
     * 앞에서 데이터를 넣게 되면, 그 뒤에 있는 데이터를 한칸씩 뒤로 옮기고 난후, 넣게됨 
     * 배열의 길이가 길수록, 연산작업이 늘어남. 느림 -> pop, push 사용
     * 
    */
    

    fruits.push();

    // start : 어디서 부터 지울껀지, deleteCount: 몇개나 지울껀지
    fruits.splice(1, 1);
    fruits.splice(1, 1, '☕️', '🥤'); // 지우고난후, 해당인덱스에 데이터를 넣을 수 있다

    const fruits2 = ['🥑','🥦'];
    const newFruits = fruits.concat(fruits2);
    console.log(newFruits);

    console.log(fruits.indexOf('🥦'));
    console.log(fruits.lastIndexOf('🍉'));
    console.log(fruits.includes('🍇')); // bool 
    


</script>

</head>
<body>
    
</body>
</html>